=Implementing Web Interaction Using Eliom=

//The code of this tutorial has been tested with Eliom 3.// \\

<<|outline target="documentation">>

This chapter of the tutorial explains how to create a small web site
with several pages, users, sessions, and other elements of classical
web development.  Then, in next chapter, we will incorporate the
features of this site with the program from the previous chapter, to
show that we can mix this kind of interaction with client-side
programs.

We assume you have read at least the first section of the previous
chapter, which explained how to create a service and constuct valid
HTML pages.

We will create a simple web site with one main page and a page for
each user (assuming we have several users already created).  Then we
will add a login/connection form. We will also add a registration
form, in order to learn how to create //dynamically// new services,
and why it is very useful.

The [[site:darcs/tutorial/files/tutorial/chapter2/|full code]]
of the program can be downloaded.

==Services==

===The main page===

Let's start again from scratch with the following site.

<<code language="ocaml"|
open Eliom_content.Html5.D

let main_service =
  Eliom_registration.Html5.register_service
    ~path:[""] ~get_params:Eliom_parameter.unit
    (fun () () ->
      Lwt.return
        (html (head (title (pcdata "")) [])
                       (body [h1 [pcdata "Hello"]])))
>>

Note that we are using {{{Eliom_registration.Html5}}}, as we are not building a
client side program for now.

For the same reason, you may want to remove the {{{.eliom}}}-file
generated by the destillery and put the code into an
{{{.ml}}}-file. But don't forget to add it to the server files in the
{{{Makefile.options}}}:

<<code language="makefile"|
SERVER_FILES := tuto.ml
>>

===Adding a page for each user===

<<concepts|

Services with parameters\\
Using parts of the path as parameters

>>

We will now create a page for each user. To do this, we will create a
new service, taking the user name as parameter:

<<code language="ocaml"|
let user_service =
  Eliom_registration.Html5.register_service
    ~path:[""] ~get_params:(Eliom_parameter.string "name")
    (fun name () ->
      Lwt.return
        (html (head (title (pcdata name)) [])
                       (body [h1 [pcdata name]])))
>>

Add these lines to the same file, compile, start the server and verify
that everything is working by trying, for example:
{{{http://localhost:8080/?name=toto}}}.

<<concept title="Paths" |

Note that we are using the same path as the first service.  Eliom will
automatically call the right service according to the parameters given
in the request.

>>

<<concept title="Services with parameters" |

To define a service that accepts parameters in the URL (GET
parameters), just add a description of the parameters you want in the
{{{~get_params}}} argument of the {{{register_service}}} function. In
our example, the service is expecting a parameter called {{{name}}},
of type {{{string}}}.

The handler function (function implementing the service) always takes
two parameters:

* The first one corresponds to GET parameters (in our example, a string).
* The second one corresponds to parameters that are sent in the body
  of the HTTP request (POST parameters). We will see soon how to make
  services with POST parameters.

The module <<a_api project="eliom" | module Eliom_parameter >>
defines the possible parameter types. For example if you write:

{{{
~get_params:(Eliom_parameter.int "i")
}}}

Eliom will try to find a parameter called {{{i}}} and to translate it
into an {{{int}}}.  In that case, the handler function will accept an
{{{int}}} as the first parameter.

If you want to accept several parameters, you can do, for example:

{{{
~get_params:(int "i" ** string "s")
}}}

after opening the {{{Eliom_parameter}}} module.  In that case, the
handler function takes a pair of type {{{(int * string)}}}.

//Warning:// The operator {{{**}}} is an infix //binary// operator.
It will always create pairs, and not triples or other tuples.

The module <<a_api project="eliom" | module Eliom_parameter >> also
defines other parameter types: for example floats, 64 bits integers,
sum types, but also more complex types, like sets or lists of values.
It is also possible to define your own parameter types.

>> <<| END "encadre" >>

For our program, we would prefer to take one part of the URL path as the parameter
describing the name of the user.
I change the definition of my service this way:

<<code language="ocaml"|
let user_service =
  Eliom_registration.Html5.register_service
    ~path:["users"]
    ~get_params:
       (Eliom_parameter.suffix (Eliom_parameter.string "name"))
    (fun name () -> ... )
>>

The user pages are now available at URLs <<span
class="code"|~http:~//localhost:8080/users~///username//>>.

<<concept title="Using parts of the path as page parameters" |

The module <<a_api project="eliom" | module Eliom_parameter >> makes
it possible to use parts of the path as service (GET) parameters.

In addition to <<a_api project="eliom" | val Eliom_parameter.suffix
>>, there are many other values allowing you to specify your expected
parameters: for example, you may access the full suffix as a string,
as a list of string, or you may want to mix suffix parameters with
standard GET parameters. You can also accept, as parameters, parts of
the path that are not a suffix of the path (using <<a_api
project="eliom" | val Eliom_parameter.const >>).  See more information
on suffixes in <<a_manual
project="eliom" chapter="server-params" fragment="suffixes"|Eliom's manual>>.

//Warning:// Even if it is not displayed in the URL, suffix parameters
have a parameter name. This allows one to make forms that point to
those kind of services.  Actually each "suffix service" has an
equivalent without suffix (which is by default automatically
redirected towards the suffix version if it is a GET request).

>> <<| END "encadre" >>

===Links===

<<concepts|
Links \\
Database libraries
>>

We now want to add a link on each user page to go back to the main
page.

Change the handler of {{{user_service}}} into:

<<code language="ocaml"|
(fun name () -> Lwt.return
  (html
    (head (title (pcdata name)) [])
    (body [h1 [pcdata name];
           p [a ~service:main_service [pcdata "Home"] ()]])))
>>

<<concept title="Creating hyperlinks" |

The function <<a_api project="eliom" | val
Eliom_content.Html5.D.a >> accepts the following parameters:
* the service
* the content of the link
* URL parameters to be given to the service

Thus, you don't have to know the precise URL of the service you want
to link to, and if the URL changes, all links will remain valid.
Using this function has a wonderful consequence: //You will never have
broken links!//

>> <<| END "encadre" >>

====Links towards services with parameters====

In our example above, the last parameter is {{{()}}} because the
service does not expect any parameter. If the service expects, for
example, a pair {{{(int * string)}}}, you must provide a matching
value as last parameter.  OCaml checks at compile time that the type
of the parameters in a link corresponds to the type expected by the
service! Also note that the parameter names are generated
automatically from the service, making it impossible to erroneously
create bad links.

To show an example of a link with parameters, we will display the list
of user pages on the main page. Here is the new version of the full
program:

<<code language="ocaml"|
open Eliom_content.Html5.D

let main_service =
  Eliom_service.Http.service ~path:[""] ~get_params:Eliom_parameter.unit ()

let user_service =
  Eliom_service.Http.service
    ~path:["users"] ~get_params:Eliom_parameter.(suffix (string "name")) ()

(* User names and passwords: *)
let users = ref [("Calvin", "123"); ("Hobbes", "456")]

let user_links () =
  ul (List.map (fun (name, _) ->
                  li [a
                        ~service:user_service [pcdata name] name])
               !users)

let _ =
  Eliom_registration.Html5.register
    ~service:main_service
    (fun () () ->
      Lwt.return
        (html (head (title (pcdata "")) [])
              (body [h1 [pcdata "Hello"];
                     user_links ()])));

  Eliom_registration.Html5.register
    ~service:user_service
    (fun name () ->
      Lwt.return
        (html (head (title (pcdata name)) [])
              (body [h1 [pcdata name];
                     p [a ~service:main_service [pcdata "Home"] ()]])));
>>

<<concept title="Mutually recursive services" |

As my two services are mutually recursive (the first one contains
links towards the second one and vice versa), we split the
{{{register_service}}} in two steps:

* First we create all the services using
  <<a_api project="eliom" | val Eliom_service.Http.service >>
  or <<a_api project="eliom" | val Eliom_service.App.service >>
  (depending on the type of services you want)
* Then we register the handlers using the {{{register}}} function from
  the right module.

The function {{{register_service}}} is just a shortcut for these two functions.

>>

<<concept title="Database libraries" |

Ultimately we'll want to use a more sophisticated database module for
managing user information, which we will write later in this tutorial.
You can use any OCaml database binding (for example
[[http://pgocaml.forge.ocamlcore.org/|PGOcaml]] to program
database queries). We will use our own database library called
[[wiki(25):|Macaque]], which implements typed requests using
//comprehensions//.

//Just remember that your query functions must be cooperative with
Lwt!// For example PGOcaml is now implemented in monadic way, which
makes it 100% compatible with Lwt. Macaque (the library we use later
in this tutorial) is as well.

If your database module is not Lwt-cooperative but is thread-safe (for
preemptive threads), you can use the <<a_api project="lwt" | val
Lwt_preemptive.detach >> function to make the blocking function be
executed by a separate preemptive thread.

>>

==Sessions==

===Connection service===

<<concepts|

Services with hidden (POST) parameters\\
Fallback service

>>

Now I want to add a connection form.  First, I will create a service
for checking the name and password.  Since I don't want the username
and password to be shown in the URL, I will use //hidden parameters//
(or POST parameters).  Thus, I'll need to create a new service taking
these parameters:

<<code language="ocaml"|
let connection_service =
  Eliom_service.Http.post_service
    ~fallback:main_service
    ~post_params:Eliom_parameter.(string "name" ** string "password")
    ()
>>

<<concept title="Hidden (POST) services" |

Services using the POST HTTP method are created using the function
<<a_api project="eliom" | val Eliom_service.Http.post_service >>
or <<a_api project="eliom" | val Eliom_service.App.post_service >>
(depending on what type of service you want to create).
As you can see, there is a major
difference from the function <<a_api project="eliom" |
val Eliom_service.Http.service >>
(and <<a_api project="eliom" | val Eliom_service.App.service >>):
{{{post_service}}} does not take a path
as parameter, but a GET service as a //fallback//.

This means that for each POST service, you must first create a GET
service at the same path that will answer if the user sets a bookmark
on the page and returns later without POST parameters.  In this way,
you will not get 404 errors if POST parameters are missing.

If the fallback has GET parameters, your service will have both GET
and POST parameters. In that case, GET parameters will be in the URL
and POST parameters will probably come from a form. In HTML, it is not
possible to mix GET and POST parameters in the same form.

See also [[site:overview/cheatsheet|the cheat-sheet]] for an
comprehensive overview on the different types of services.

>>

<<concept title="POST or GET?" |

POST parameters are sent in the body of the HTTP request (whereas GET
parameters are sent in the URL).  It is important to understand that
they have very different semantics.

Remember:

* Use GET parameters when you want your page to be bookmarkable.
* Use POST parameters when you do not want the page to be
  bookmarkable, for example, because it performs a side effect on the
  server (connecting a user, add something in a database, perform a
  payment, etc.).

//Warning:// Even if POST parameters are not shown in the URL, they
are sent as plain text. If you want to transmit private data (like a password),
you must
use HTTPS (see <<a_manual project="ocsigenserver" chapter="config" |
the Ocsigen server manual >>).  >>

Now you can register a handler for the new service:

<<code language="ocaml"|
  Eliom_registration.Html5.register
    ~service:connection_service
    (fun () (name, password) ->
      let message =
        if check_pwd name password
        then "Hello "^name
        else "Wrong name or password"
      in
      Lwt.return
        (html (head (title (pcdata "")) [])
              (body [h1 [pcdata message];
                     user_links ()])));
>>

where {{{check_pwd}}} is defined by:

<<code language="ocaml"|
let check_pwd name pwd =
  try List.assoc name !users = pwd with Not_found -> false
>>

===Connection form===

<<concepts|

Forms

>>

For now, I will add the connection form only on the main page of the
site.

Let's create a function for generating the form:

<<code language="ocaml"|
let connection_box () =
  post_form ~service:connection_service
    (fun (name1, name2) ->
      [fieldset
         [label ~a:[a_for name1] [pcdata "login: "];
          string_input ~input_type:`Text
                                          ~name:name1 ();
          br ();
          label ~a:[a_for name2] [pcdata "password: "];
          string_input ~input_type:`Password
                                          ~name:name2 ();
          br ();
          string_input ~input_type:`Submit
                                          ~value:"Connect" ()
         ]]) ()
>>

Now, add a call to this function in the handler of the main service
(for example just before the user links).

<<concept title="Forms" |

Form creation is very similar to link creation, using the functions
<<a_api project="eliom" | val
Eliom_content.Html5.D.get_form >> and <<a_api project="eliom"
| val Eliom_content.Html5.D.post_form >>.

The first parameter is the service, and the last parameter (only for
{{{post_form}}}) is for GET parameters you want sent in the URL, if
the fallback of your POST service takes GET parameters.

The only difference is how we write form content: instead of simply
giving the content as parameter to the {{{get_form}}} or
{{{post_form}}} functions, you supply a function that creates the form
from the names of the parameters the service is expecting.  Thus, you
don't need to remember the parameter names you chose while creating
the service, and you can change them easily without having to update
every form in your application.

In the example, note that the service is expecting a pair
{{{(string * string)}}}.  The function given to {{{post_form}}} takes two
parameters corresponding to the names of each field.

<<a_api project="eliom" | module Eliom_content.Html5.D >> (and
<<a_api project="eliom" | module Eliom_content.Html5.F >>)
defines constructors for all possible form fields.  OCaml checks that
the name you use matches the field.  For example it is not possible to
use the names above with <<a_api project="eliom" | val
Eliom_content.Html5.D.int_input >> as it is a name for a string.  >>

===Opening a session===

<<concepts|

Session data, Eliom references

>>

Now we want to remember that the user is successfully connected.  To do
that we will set a reference when the user successfully connects, and
we will restrict the scope of this reference to the session (that is,
to the browser).

Define your Eliom reference with a default value:
<<code language="ocaml"|
let username = Eliom_reference.eref ~scope:Eliom_common.default_session_scope None
>>

Here is the new {{{connection_box}}} function:

<<code language="ocaml"|
let connection_box () =
  lwt u = Eliom_reference.get username in
  Lwt.return
    (match u with
      | Some s -> p [pcdata "You are connected as "; pcdata s]
      | None ->
        post_form ~service:connection_service
          (fun (name1, name2) ->
            [fieldset
	       [label ~a:[a_for name1] [pcdata "login: "];
                string_input ~input_type:`Text
                                                ~name:name1 ();
                br ();
                label ~a:[a_for name2] [pcdata "password: "];
                string_input ~input_type:`Password
                                                ~name:name2 ();
                br ();
                string_input ~input_type:`Submit
                                                ~value:"Connect" ()
               ]]) ())
>>

...~ and replace the registration of the main service and the connection service by:

<<code language="ocaml"|
  Eliom_registration.Html5.register
    ~service:main_service
    (fun () () ->
      lwt cf = connection_box () in
      Lwt.return
        (html (head (title (pcdata "")) [])
              (body [h1 [pcdata "Hello"];
                     cf;
                     user_links ()])));

  Eliom_registration.Html5.register
    ~service:connection_service
    (fun () (name, password) ->
      lwt message =
        if check_pwd name password
        then begin
          Eliom_reference.set username (Some name) ~>>=
            (fun _ -> Lwt.return ("Hello "^name))
        end else
	  Lwt.return "Wrong name or password" in
      Lwt.return
        (html (head (title (pcdata "")) [])
              (body [h1 [pcdata message];
                     user_links ()])));
>>


<<concept title="Eliom references and extended sessions" |

Session data is stored in what we call //Eliom references//.
It is a type of reference whose value depend on the session the user
belongs to.

Eliom is making the notion of session much more powerful by adding
other //scopes// for Eliom references. Instead of limiting the scope
to a session (that is: one browser), it is also possible to create
Eliom references with scope "client-side process"
({{{~scope:Eliom_common.default_process_scope}}}), or "group of sessions" (see
later) ({{{~scope:Eliom_common.default_group_scope}}}), or "current
request" ({{{~scope:Eliom_common.request_scope}}}).

Example: Say you want to implement a game, and make possible to have several instances of the game running in several tabs of the browser. Store the score on server side, as a "client side process" Eliom reference.

Example: Grouping all the sessions for one user in a group of session makes possible to share a shopping basket between several devices (your mobile phone and your laptop for example).

An Eliom reference is defined with the function
{{{Eliom_reference.eref}}}, specifying the scope of this reference
and the default value. The function {{{Eliom_reference.get}}}
retrieves the value of this reference for the current scope.
The default value is used for
all sessions (or client process or group of sessions) for which it has not
been changed using {{{Eliom_reference.set}}}.

By default, Eliom references are kept in memory and will disappear if
you shut down the server. It is possible, however, to create
//persistent Eliom references// that will survive even a server
restart. To do that, add the optional parameter {{{persistent}}} to
the {{{eref}}} function, with a string value corresponding to the name
of the table that will contain the values on disk.

<<wip|

For now you need to rename this table every time you change the type
of your Eliom reference, otherwise the server will crash (we are using
OCaml's {{{Marshal}}} module).

>>

<<wip|

It is not possible to create Eliom references containing functions
(closures). We hope OCaml will include some mechanism to do that soon.

>>

>> <<| END "encadre" >>

===Display the usual page after connection===

<<concepts|

Actions

>>

As you can see, our connection service is displaying a welcome page
which is different from the main page in connected mode.  We would
rather display the same page.  One solution is to call the same
handler after registering session data.

A cleaner solution is to use an //action//, that is: a service which will
just perform a side effect.  Replace the registration
of the connection service by:

<<code language="ocaml"|
  Eliom_registration.Action.register
    ~service:connection_service
    (fun () (name, password) ->
      if check_pwd name password
      then Eliom_reference.set username (Some name)
      else Lwt.return ());
>>

Now the main page is displayed after connection.

<<concept title="Actions" |

An //action// is a service that performs a side effect and redisplays
the current page. The handler function returns {{{()}}}.

>>

===Putting a connection form on each page===

<<concepts|

Non-attached coservices\\
Redirections

>>

<<concept title="Non-attached coservices" |

With many web programming frameworks, adding a connection form on each
page of a site is complicated, and is approached in one of two ways:

* A first solution is similar to what we did for the main service, but
  for all services (meaning that each page usually checks the presence
  of POST parameters). This is clumsy.
* Another solution would be to create a special page on a separate
  path to handle the registration, with some way to do a redirection
  to the page we came from after connection. (Of course we want to
  stay on the same page after sending the connection form!) This is
  ugly.

With Eliom, this is more straightforward:

* For the connection service, we use a kind of service called
  //non-attached coservice//, which means that it is not attached to
  any path in particular. Calling this kind of service will not change
  the //path// you see in the browser URL bar (just add parameters if
  you use the GET method).
* Use an action to connect the user and redisplay the page
  corresponding to the current URL.

By default, a random identifier will be generated automatically by
Eliom for the non-attached coservice. If you want this identifier to
be fixed, you can specify it yourself while creating the service using
the {{{?name}}} optional parameter. This identifier is added
automatically by Eliom in each form (as hidden field) and link.

>>

Transform the connection service into a non-attached coservice:

<<code language="ocaml"|
let connection_service =
  Eliom_service.Http.post_coservice'
    ~post_params:Eliom_parameter.(string "name" ** string "password")
    ()
>>

Now you can add the connection box on user pages.

<<code language="ocaml"|
  Eliom_registration.Html5.register
    ~service:user_service
    (fun name () ->
      lwt cf = connection_box () in
      Lwt.return
        (html (head (title (pcdata name)) [])
              (body [h1 [pcdata name];
                     cf;
                     p [a
                          ~service:main_service [pcdata "Home"] ()]])));
>>

<<concept title="Altenative: register a redirection" |

Usually, after sending a POST form, it is good practice to do a
redirection.  This avoids reposting the data if the user reloads the
page.

Eliom provides the module <<a_api project="eliom" |
module Eliom_registration.Redirection >> to register services doing
redirections.  Such services return a service without parameter.

Example:

<<code language="ocaml"|
let redir_service = Eliom_registration.Redirection.register_service
    ~path:["redir"]
    ~get_params:Eliom_parameter.unit
   (fun () () -> Lwt.return main_service)
>>

(If you want to give parameters to the service you return, use <<a_api
project="eliom" | val Eliom_service.preapply >> ---
more information in the <<a_manual project="eliom" chapter="server-services"
fragment="p3preapplied" | Eliom manual >>.)

If you want to do a redirection towards the current page (as in our
case), use the special service <<a_api project="eliom" |
val Eliom_service.void_coservice' >>, which is some kind of POST
non-attached coservice without parameter at all.  >>

===Disconnection===

To create a logout/disconnection form, we create another non-attached
coservice using POST method, and register another action.  We call the
function <<a_api project="eliom" | val
Eliom_state.discard >> with scope <<a_api project="eliom"
| val Eliom_common.default_session_scope >> to remove all session
data.

<<code language="ocaml"|
let disconnection_service =
  Eliom_service.Http.post_coservice' ~post_params:Eliom_parameter.unit ()

let disconnect_box () =
  post_form disconnection_service
    (fun _ -> [p [string_input
                    ~input_type:`Submit ~value:"Log out" ()]]) ()

let _ =
  Eliom_registration.Action.register
    ~service:disconnection_service
    (fun () () -> Eliom_state.discard ~scope:Eliom_common.default_session_scope ())
>>

Then add this form in the connection box:

<<code language="ocaml"|
let connection_box () =
  lwt u = Eliom_reference.get username in
  Lwt.return
    (match u with
      | Some s -> div [p [pcdata "You are connected as "; pcdata s; ];
                       disconnect_box () ]
      | None -> ...
>>

==Registration of users==

===Basic registration form===

<<concepts|

Attached coservice

>>

We will now add a registration form to the application.  We create a
new regular service, attached to the path {{{/registration}}}, that
displays a registration form, and an action that will add the user to
the "database":

<<code language="ocaml"|
let new_user_form_service =
  Eliom_service.Http.service ~path:["registration"] ~get_params:Eliom_parameter.unit ()

let create_account_service =
  Eliom_service.Http.post_coservice
    ~fallback:main_service
    ~post_params:Eliom_parameter.(string "name" ** string "password") ()

let account_form =
  post_form ~service:create_account_service
    (fun (name1, name2) ->
      [fieldset
         [label ~a:[a_for name1] [pcdata "login: "];
          string_input ~input_type:`Text ~name:name1 ();
          br ();
          label ~a:[a_for name2] [pcdata "password: "];
          string_input ~input_type:`Password ~name:name2 ();
          br ();
          string_input ~input_type:`Submit ~value:"Connect" ()
         ]]) ()

let _ =
  Eliom_registration.Html5.register
    ~service:new_user_form_service
    (fun () () ->
      Lwt.return
        (html (head (title (pcdata "")) [])
              (body [h1 [pcdata "Create an account"];
                     account_form;
                    ])));

  Eliom_registration.Action.register
    ~service:create_account_service
    (fun () (name, pwd) ->
      users := (name, pwd)::!users;
      Lwt.return ())
>>

Then add the link to this service in the connection box:

<<code language="ocaml"|
let connection_box () =
  lwt u = Eliom_reference.get username in
  Lwt.return
    (match u with
      | Some s -> div [p [pcdata "You are connected as "; pcdata s; ];
                       disconnect_box () ]
      | None ->
        div [post_form ~service:connection_service
                (fun (name1, name2) ->
...
                ) ();
             p [a new_user_form_service
                  [pcdata "Create an account"] ()]]
            )
>>

<<concept title="Attached coservice" |

Here I want to return to the main page after account creation.  I'm
using an //attached coservice//, that is, a service that is identified
by both the path in the URL and a special coservice number (or name).
A form to such a service will change the path and send parameters
together with the coservice identifier (added automatically in an
hidden field).

In this particular case, We could have used a regular service, as we
do not really need the coservice identifier, but in many cases, you
may want to distinguish between several services registered at the
same path (and with same parameters).  That's what attached coservices
are made for.

>>

===Registration form with confirmation===

<<concepts|

Dynamic registration of services\\
Session services

>>

Now we want to add a confirmation page before actually creating the
account.  We //replace// the service {{{create_account_service}}} by a
new POST attached coservice called {{{account_confirmation_service}}}:

<<code language="ocaml"|
let account_confirmation_service =
  Eliom_service.Http.post_coservice
    ~fallback:new_user_form_service
    ~post_params:Eliom_parameter.(string "name" ** string "password")
    ()
>>

and we make the account creation form point at this new service.

We register an HTML handler on this service, with the confirmation
page.  As a side effect, this page will create the actual account
creation service:

<<code language="ocaml"|
Eliom_registration.Html5.register
  ~service:account_confirmation_service
  (fun () (name, pwd) ->
    let create_account_service =
      Eliom_registration.Action.register_coservice
        ~fallback:main_service
        ~get_params:Eliom_parameter.unit
        ~timeout:60.
        (fun () () ->
          users := (name, pwd)::!users;
          Lwt.return ())
    in
    Lwt.return
      (html
        (head (title (pcdata "")) [])
          (body
            [h1 [pcdata "Confirm account creation for "; pcdata name];
             p [a ~service:create_account_service [pcdata "Yes"] ();
                pcdata " ";
                a ~service:main_service [pcdata "No"] ()]
            ])));
>>

Also remove the registration of the {{{create_account_service}}}
service and modify the user creation form to make it points towards
{{{account_confirmation_service}}}.

<<|BB
  After the actual creation of the user, {{{create_account_service}}} stays
  accessible. Reloading re-creates the same user again.
  >>

<<concept title="Dynamic creation of services" |

In this example, we are dynamically creating a new service (here a
coservice that does an action).  This is done by the same
{{{register}}} function as usual.

Dynamic creation of new services allows one to create services that
depend on previous interaction with the user.  Here the
{{{create_account_service}}} service depends on {{{name}}} and
{{{pwd}}}, that were previously sent by a form.

In this simple example, an alternative would have been to send
{{{name}}} and {{{pwd}}} again to the same service as in the "basic
registration form" example. But this solution is not possible when you
have too much data.

//Saving {{{name}}} and {{{pwd}}} as session data is a wrong
solution!// If the user duplicates his browser window and fills out
the user creation form in both, then the confirmation link must create
the right account!

A working alternative would have been to generate a random key, and
associate {{{name}}} and {{{pwd}}} with that key in a database table
on the server. This is the way such kind of web interaction is usually
implemented. However, Eliom's solution is much simpler.

The ability to register new services dynamically is implemented in few
web frameworks, even though it simplifies a lot the programmating
involved with that type of web interaction.  This feature is a variant
of what is called //continuation based web programming//.  Think about
it when you want to //create a page that depends on previous
interaction with the user//. Dynamic registration of services will
automatically record the "history" of the interaction, and make
possible to use the "back button" or to have several tabs on the same
site.

Examples of uses:
* displaying the results of a search
* programming a "several step form" (when a form points at another
  one, etc., like our registration form with confirmation).

On the other hand, if you want to implement a //shopping basket//, you
want it to be shared between all tabs of your web site.  To do that,
you will use session data.

//Warning:// Services are kept in memory. To avoid memory leaks, you
probably want to put a timeout on your dynamic coservices. Just add
the optional parameter {{{?timeout}}} to the service creation
function.

>> <<| END "encadre" >>

<<concept title="Session services" |

Eliom also makes it possible to restrict the scope of services to a
session, a group of sessions, or even a client side process (if you
have a client side program running).  It works exactly like the scope
of Eliom references.  To do that, just add the optional parameter
{{{~scope}}} to the registration function.  By default, the value is
{{{Eliom_common.global_scope}}} (visible for everyone).  Other possible
values: {{{Eliom_common.default_session_scope}}}, {{{Eliom_common.default_group_scope}}},
or {{{Eliom_common.default_process_scope}}}.

It is possible to register again for a session, tab or group, services
that have already been registered with public (site) visibility.  In
such cases, Eliom will try first tab services, then session services,
then group services, and finally site services.  This makes possible
to register specialized versions of a service for one user, for
example when she logs in.

>>

==A few enhancements==

===Displaying a "wrong password" message===

<<concepts|
Scope "request"
>>

In the current version, our web site fails silently when the password
is wrong.  Let's improve this behavior by displaying an error message.
To do that, we need to pass information to the service occurring after
the action. We record this information in an Eliom reference with
scope {{{Eliom_common.request_scope}}}.

Define an Eliom reference:

<<code language="ocaml"|
let wrong_pwd = Eliom_reference.eref ~scope:Eliom_common.request_scope false
>>

Modify the connection box this way:

<<code language="ocaml"|
let connection_box () =
  lwt u = Eliom_reference.get username in
  lwt wp = Eliom_reference.get wrong_pwd in
  Lwt.return
    (match u with
      | Some s -> div [p [pcdata "You are connected as "; pcdata s; ];
                       disconnect_box () ]
      | None ->
        let l =
          [post_form ~service:connection_service
            (fun (name1, name2) ->
              [fieldset
	         [label ~a:[a_for name1] [pcdata "login: "];
                  string_input ~input_type:`Text ~name:name1 ();
                  br ();
                  label ~a:[a_for name2] [pcdata "password: "];
                  string_input ~input_type:`Password ~name:name2 ();
                  br ();
                  string_input ~input_type:`Submit ~value:"Connect" ()
                 ]]) ();
             p [a new_user_form_service
                  [pcdata "Create an account"] ()]]
        in
        if wp
        then div ((p [em [pcdata "Wrong user or password"]])::l)
        else div l
    )
>>

...~ and modify the {{{connection_service}}} handler:

<<code language="ocaml"|
  Eliom_registration.Action.register
    ~service:connection_service
    (fun () (name, password) ->
      if check_pwd name password
      then Eliom_reference.set username (Some name)
      else Eliom_reference.set wrong_pwd true);
>>

===Sending 404 errors for non-existing users===

<<concepts|

Sending 404\\
{{{Eliom_registration.Any}}}

>>

Our service {{{user_service}}} responds to any request parameter, even
if the user does not exist in the database.  We want to check that the
user is in the database before displaying the page, and send a 404
error if the user is not.  To do that, we will replace the module
{{{ My_app }}} by <<a_api project="eliom" | module
Eliom_registration.Any >> to register the service {{{user_service}}}:

<<code language="ocaml"|
Eliom_registration.Any.register
  ~service:user_service
  (fun name () ->
    if List.exists (fun (n, _) -> n = name) !users
    then begin
      lwt cf = connection_box () in
      Eliom_registration.Html5.send
        (html (head (title (pcdata name)) [])
              (body [h1 [pcdata name];
                     cf;
                     p [a ~service:main_service [pcdata "Home"] ()]]))
    end else
      Eliom_registration.Html5.send
        ~code:404
        (html (head (title (pcdata "404")) [])
              (body [h1 [pcdata "404"];
                     p [pcdata "That page does not exist"]]))
    );
>>

<<| BB
  Why not {{{raise_lwt Eliom_common.Eliom_404}}}?
  >>

<<concept title="Eliom_registration.Any" |

The module <<a_api project="eliom" | module
Eliom_registration.Any >> can be used to create services that are
flexible to choose the kind of output they want to send.

Use the {{{send}}} function from the module you want to send the
output.  That function also allows, for example, to specify the HTTP
response code (here, we choose to use 404) or to set HTTP headers.

>>

<<wip|

In the future, we may add functions like {{{set_http_code}}} or
{{{set_http_header}}} to personalize the answer without using
{{{Eliom_registration.Any}}}.

>>

=== Wrapping the server handler to easily get the user data

When you want to assume that you have informations available in
sessions, for instance when a site is mainly available to connected
users, it becomes tedious to check everywhere that a reference is not
{{{None}}}.  A simple way to distinguish authenticated and anonymous
requests lies in the usage of <<a_api project="eliom"
subproject="server"|val Eliom_tools.wrap_handler>>. It allows to
provide two handler functions, one is called if a certain
information is not made available by the first argument, the other is
called when that information is available.

<<code language="ocaml"|

let authenticated_handler f =
  let handle_anonymous _get _post =
    let connection_box =
      let open Html5.F in
      post_form ~service:connection_service
        (fun (name1, name2) ->
	  [fieldset
              [label ~a:[a_for name1] [pcdata "login: "];
               string_input ~input_type:`Text ~name:name1 ();
               br ();
               label ~a:[a_for name2] [pcdata "password: "];
               string_input ~input_type:`Password ~name:name2 ();
               br ();
               string_input ~input_type:`Submit ~value:"Connect" ()
              ]]) ()
    in
    Lwt.return
      Html5.F.(html
                 (head (title (pcdata "")) [])
                 (body [h1 [pcdata "Please connect"];
	                connection_box;]))
    in
    Eliom_tools.wrap_handler
      (fun () -> Eliom_reference.get username)
      handle_anonymous (* Called when [username] is [None] *)
      f (* Called [username] contains something *)

let _ = My_app.register ~service:main_service
  (authenticated_handler
    (fun username _get _post ->
       Lwt.return
         Html5.F.(html
           (head (title (pcdata "")) [])
           (body [h1 [pcdata ("Hello " ^ username) ]]))))
>>

[[wiki:application|prev]]
[[wiki:misc|next]]
